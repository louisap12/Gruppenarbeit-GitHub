else Modalwert <- names(table(x)[table(x) == max(table(x))]) ##Auspraegung, die am haeufigsten vorkommt
Maximum <- max(x)
Minimum <- min(x)
Spannweite <- length(unique(x)) ##Anzahl der verschiedenen Auspraegungen der Variablen
uebersicht_kat <- list("Modalwert" = Modalwert, "Maximum" = Maximum, "Minimum" = Minimum, "Spannweite" = Spannweite) ##bringe Werte in eine Liste
return(uebersicht_kat) ##gibt die Liste aus
}
sapply( Datensatz[ ,5:6], kat)
# Data Science
sapply( ds[ ,5:6], kat)         # Beim Vergleich der Modalwerte ergibt sich:
# Statistik
sapply( st[ ,5:6], kat)
# Informatik
sapply( inf[ ,5:6], kat)
# Mathe
sapply( ma[ ,5:6], kat)         # Mit dem Modalwert von 5 bei Int.Mathe scheint im Vergleich zum Modalwert
table(Datensatz$`Mathe-LK`) # Die Mehrheit der Studierenden hat einen Mathe-LK belegt.
# Data Science            # Recht ausgeglichenes Verhaeltniss.
table(ds$`Mathe-LK`)
# Statistik               # Deutlich mehr Studierende haben den Mathe-LK besucht.
table(st$`Mathe-LK`)
# Informatik              # Etwas mehr Studierende haben den Mathe-LK besucht.(auch eher ausgeglichen)
table(inf$`Mathe-LK`)
# Mathe
table(ma$`Mathe-LK`)      # Nahezu alle Studierende haben den Mathe-LK besucht.
kat_zsh <- function(x,y){
# Zunaechst eine Bedingung, die die beiden Vektoren erfuellen sollen:
if( length(x) != length(y) ){ stop("Beide Objekte muessen dieselbe Laenge haben.")}
kor <- cor( as.numeric(x), as.numeric(y) )
kov <- cov( as.numeric(x), as.numeric(y) )
return( list( Kovarianz = kov, Korrelation = kor) )  # Ausgabe in einer Liste
}
kat_zsh(Datensatz$`Int. Prog.`, Datensatz$`Int. Mathe`)
kat_zsh(Datensatz$Alter, Datensatz$`Int. Mathe`)
kat_zsh(Datensatz$Alter, Datensatz$`Int. Prog.`)
Datensatz$`Int. Mathe` <- as.numeric(Datensatz$`Int. Mathe`)
Datensatz$`Int. Prog.` <- as.numeric(Datensatz$`Int. Prog.`)
Datensatz$`Mathe-LK` <- as.character(Datensatz$`Mathe-LK`)
dich_as_met <- function(x){
name <- unique(x)
result <- x == name[which.min(nchar(name))]
return(as.numeric(result))
}
met_dich <- function(x,y){
# x soll die metrische Variable sein
# y soll die dichotome Variable sein
if(!is.numeric(x)) stop("Der erste Vektor ist nicht metrisch")
if(length(levels(factor(y))) != 2) stop("Der zweite Vektor ist nicht dichotom")
y <- dich_as_met(y)
return(list("Korrelation" = cor(x,y), "Kovarianz" = cov(x,y),
"Lineares Modell" = lm(y~x)))
}
met_dich(Datensatz$`Int. Mathe`, Datensatz$`Mathe-LK`)
# Regressionsgerade:
y <- dich_as_met(Datensatz$`Mathe-LK`)
y
plot( y ~ Datensatz$`Int. Mathe` )
abline( 0.58992, 0.02187)
met_dich(Datensatz$`Int. Prog.`, Datensatz$`Mathe-LK`)
# Regressionsgerade:
plot( y ~ Datensatz$`Int. Prog.` )
abline( 0.637350 , 0.009584)
# Wandle Variablen wieder in die korrekten Datentypen um
Datensatz$`Int. Mathe` <- as.factor( Datensatz$`Int. Mathe`)
Datensatz$`Int. Mathe` <- ordered( Datensatz$`Int. Mathe` , levels = c("1", "2", "3", "4", "5", "6", "7") )
Datensatz$`Int. Prog.` <- as.factor( Datensatz$`Int. Prog.`)
Datensatz$`Int. Prog.` <- ordered( Datensatz$`Int. Prog.` , levels = c("1", "2", "3", "4", "5", "6", "7") )
Datensatz$`Mathe-LK` <- as.factor( Datensatz$`Mathe-LK`)
# Funktion aus e):
qkat <- function(y){
if ( (is.numeric(y) == TRUE) || (is.ordered(y) == TRUE) )  {
x <- as.numeric(y)
x
n <- x[which( x <= quantile(x, 1/3))]
m <- x
m <- m [which( ! m <= quantile(x, 1/3))]
m <- m [which( ! m > quantile(x, 2/3))]
h <- x[which( x > quantile(x, 2/3))]
l <- list(n, m, h)
names(l) <- c("niedrig (<= 1/3-Quantil)", "mittel (1/3-Quantil < & <= 2/3-Quantil)", "hoch (2/3-Quantil <)")
return(l)
}
else{
stop("Nicht moeglich, da Variable nicht mindestens ordinalskaliert.")
}
}
qkat(Datensatz$`Int. Mathe`)
qkat(Datensatz$`Int. Prog.`)
# Funktion aus f):
visual <- function(x,i){
p <- length(i)
q <- sqrt(p)
if(round(q)^2 == p)
par(mfcol = c(q,q))
else
par(mfcol=c(q,q+1))
for (u in 1:p) {
barplot(table(x[i[u]]), xlab = colnames(Datensatz)[i[u]],
ylab = "abs. HÃ¤ufigkeit" ,main = "Visualisierung")
}
}
visual(Datensatz,3:6)
# Das Alter ist nahzu normalverteilt um 25 Jahre. Lediglich im Bereich 26 bis 27 liegen weniger
# Bei den Studiengaengen sind Data Science,Statistik und Informatik nahezu gleich oft vertreten.
# Hier bestaetigen sich bei der Verteilung der Bewertungsstufen die Erkenntnisse aus e). Beim Mathe-
plot( y ~ Datensatz$`Int. Mathe` )
library(readr)
Datensatz <- read_csv("Datensatz.csv")
Datensatz
sum_met <- function(x){
if( is.numeric(x) != TRUE){ stop("Die Variable muss metrisch skaliert sein.") } # Warnmeldung falls Variable
AM <- mean(x)                                                                  # nicht metrisch ist.
med <- median(x)    # Hier werden alle Statistiken berechnet.
var <- var(x)
sd <- sd(x)
quartile <- quantile(x, probs= c(0.25,0.75) )
extrm <- c( Minimum = min (x), Maximum = max (x))
return( list( "Arithmetische Mittel" = AM, "Median" = med, "Varianz" = var, "Standardabweichung" = sd,
"Quartile"= quartile, "Etremwerte" = extrm) )      # Alle benoetigten Groessen werden in einer Liste ausgegeben.
}
sum_met(Datensatz$Alter)    # Das durchschnittliche Alter liegt bei 24.34 Jahren bzw. (bezueglich des
sum_met(Datensatz$`Int. Mathe`)   # Int.Prog wirs insgesamte etwas hoher bewerte als Int.Mathe.
sum_met(Datensatz$`Int. Prog.`)   # vgl. Median von 4 bei Int.Mathe und Median von 5 bei Int.Prog.
# Moegliche Studienfaecher ausfindig machen:
unique( Datensatz$Studienfach)
table( Datensatz$Studienfach)/length( Datensatz$Studienfach)
# Erstellung von Teildatensaetzen um Unterschiede zwischen den Studiengaengen herausfinden zu koennen
ds <- Datensatz[ Datensatz$Studienfach == "Data Science", ]
st <- Datensatz[ Datensatz$Studienfach == "Statistik", ]
inf <- Datensatz[ Datensatz$Studienfach == "Informatik", ]
ma <- Datensatz[ Datensatz$Studienfach == "Mathe", ]
sapply( list( Data_Science = ds$`Int. Mathe`, Statistik = st$`Int. Mathe`,
Informatik = inf$`Int. Mathe`, Mathe = ma$`Int. Mathe`) , sum_met)[1:4,]
sapply( list( Data_Science = ds$`Int. Prog.`, Statistik = st$`Int. Prog.`,
Informatik = inf$`Int. Prog.`, Mathe = ma$`Int. Prog.`) , sum_met)[1:4,]
str(Datensatz)
Datensatz$`Int. Mathe` <- as.factor( Datensatz$`Int. Mathe`)
Datensatz$`Int. Mathe` <- ordered( Datensatz$`Int. Mathe` , levels = c("1", "2", "3", "4", "5", "6", "7") )
Datensatz$`Int. Prog.` <- as.factor( Datensatz$`Int. Prog.`)
Datensatz$`Int. Prog.` <- ordered( Datensatz$`Int. Prog.` , levels = c("1", "2", "3", "4", "5", "6", "7") )
Datensatz$`Mathe-LK` <- as.factor( Datensatz$`Mathe-LK`)
# Kontrolle:
str(Datensatz)
kat <- function(x){
if(is.character(x)){stop("Die Variable ist nicht kategoriell")}
else Modalwert <- names(table(x)[table(x) == max(table(x))]) ##Auspraegung, die am haeufigsten vorkommt
Maximum <- max(x)
Minimum <- min(x)
Spannweite <- length(unique(x)) ##Anzahl der verschiedenen Auspraegungen der Variablen
uebersicht_kat <- list("Modalwert" = Modalwert, "Maximum" = Maximum, "Minimum" = Minimum, "Spannweite" = Spannweite) ##bringe Werte in eine Liste
return(uebersicht_kat) ##gibt die Liste aus
}
sapply( Datensatz[ ,5:6], kat)
# Data Science
sapply( ds[ ,5:6], kat)         # Beim Vergleich der Modalwerte ergibt sich:
# Statistik
sapply( st[ ,5:6], kat)
# Informatik
sapply( inf[ ,5:6], kat)
# Mathe
sapply( ma[ ,5:6], kat)         # Mit dem Modalwert von 5 bei Int.Mathe scheint im Vergleich zum Modalwert
table(Datensatz$`Mathe-LK`) # Die Mehrheit der Studierenden hat einen Mathe-LK belegt.
# Data Science            # Recht ausgeglichenes Verhaeltniss.
table(ds$`Mathe-LK`)
# Statistik               # Deutlich mehr Studierende haben den Mathe-LK besucht.
table(st$`Mathe-LK`)
# Informatik              # Etwas mehr Studierende haben den Mathe-LK besucht.(auch eher ausgeglichen)
table(inf$`Mathe-LK`)
# Mathe
table(ma$`Mathe-LK`)      # Nahezu alle Studierende haben den Mathe-LK besucht.
kat_zsh <- function(x,y){
# Zunaechst eine Bedingung, die die beiden Vektoren erfuellen sollen:
if( length(x) != length(y) ){ stop("Beide Objekte muessen dieselbe Laenge haben.")}
kor <- cor( as.numeric(x), as.numeric(y) )
kov <- cov( as.numeric(x), as.numeric(y) )
return( list( Kovarianz = kov, Korrelation = kor) )  # Ausgabe in einer Liste
}
kat_zsh(Datensatz$`Int. Prog.`, Datensatz$`Int. Mathe`)
kat_zsh(Datensatz$Alter, Datensatz$`Int. Mathe`)
kat_zsh(Datensatz$Alter, Datensatz$`Int. Prog.`)
Datensatz$`Int. Mathe` <- as.numeric(Datensatz$`Int. Mathe`)
Datensatz$`Int. Prog.` <- as.numeric(Datensatz$`Int. Prog.`)
Datensatz$`Mathe-LK` <- as.character(Datensatz$`Mathe-LK`)
dich_as_met <- function(x){
name <- unique(x)
result <- x == name[which.min(nchar(name))]
return(as.numeric(result))
}
met_dich <- function(x,y){
# x soll die metrische Variable sein
# y soll die dichotome Variable sein
if(!is.numeric(x)) stop("Der erste Vektor ist nicht metrisch")
if(length(levels(factor(y))) != 2) stop("Der zweite Vektor ist nicht dichotom")
y <- dich_as_met(y)
return(list("Korrelation" = cor(x,y), "Kovarianz" = cov(x,y),
"Lineares Modell" = lm(y~x)))
}
met_dich(Datensatz$`Int. Mathe`, Datensatz$`Mathe-LK`)
# Regressionsgerade:
y <- dich_as_met(Datensatz$`Mathe-LK`)
y
plot( y ~ Datensatz$`Int. Mathe` , ylab = )
abline( 0.58992, 0.02187)
plot( y ~ Datensatz$`Int. Mathe` , ylab = "Besuch des Mathe-LK", xlab = "Interesse in Mathe",
main = "Zusmmenhang: Besuch Mathe-LK und Interesse in Mathe")
abline( 0.58992, 0.02187, col = "deepskyblue")
abline( 0.58992, 0.02187, col = "deepskyblue", lwd = 2)
# Regressionsgerade:
plot( y ~ Datensatz$`Int. Prog.` )
abline( 0.637350 , 0.009584)
# Regressionsgerade:
plot( y ~ Datensatz$`Int. Prog.`, xlab = "Interesse in Programmierung", ylab = "Besuch des Mathe-LK",
main = "Zusammenhang: Besuch Mathe-LK und Interesse in Programmierung")
abline( 0.637350 , 0.009584)
abline( 0.637350 , 0.009584, col = "deepskyblue", lwd = 2)
library(readr)
Datensatz <- read_csv("Datensatz.csv")
Datensatz
sum_met <- function(x){
if( is.numeric(x) != TRUE){ stop("Die Variable muss metrisch skaliert sein.") } # Warnmeldung falls Variable
AM <- mean(x)                                                                  # nicht metrisch ist.
med <- median(x)    # Hier werden alle Statistiken berechnet.
var <- var(x)
sd <- sd(x)
quartile <- quantile(x, probs= c(0.25,0.75) )
extrm <- c( Minimum = min (x), Maximum = max (x))
return( list( "Arithmetische Mittel" = AM, "Median" = med, "Varianz" = var, "Standardabweichung" = sd,
"Quartile"= quartile, "Etremwerte" = extrm) )      # Alle benoetigten Groessen werden in einer Liste ausgegeben.
}
sum_met(Datensatz$Alter)    # Das durchschnittliche Alter liegt bei 24.34 Jahren bzw. (bezueglich des
sum_met(Datensatz$`Int. Mathe`)   # Int.Prog wirs insgesamte etwas hoher bewerte als Int.Mathe.
sum_met(Datensatz$`Int. Prog.`)   # vgl. Median von 4 bei Int.Mathe und Median von 5 bei Int.Prog.
# Moegliche Studienfaecher ausfindig machen:
unique( Datensatz$Studienfach)
table( Datensatz$Studienfach)/length( Datensatz$Studienfach)
# Erstellung von Teildatensaetzen um Unterschiede zwischen den Studiengaengen herausfinden zu koennen
ds <- Datensatz[ Datensatz$Studienfach == "Data Science", ]
st <- Datensatz[ Datensatz$Studienfach == "Statistik", ]
inf <- Datensatz[ Datensatz$Studienfach == "Informatik", ]
ma <- Datensatz[ Datensatz$Studienfach == "Mathe", ]
sapply( list( Data_Science = ds$`Int. Mathe`, Statistik = st$`Int. Mathe`,
Informatik = inf$`Int. Mathe`, Mathe = ma$`Int. Mathe`) , sum_met)[1:4,]
sapply( list( Data_Science = ds$`Int. Prog.`, Statistik = st$`Int. Prog.`,
Informatik = inf$`Int. Prog.`, Mathe = ma$`Int. Prog.`) , sum_met)[1:4,]
str(Datensatz)
Datensatz$`Int. Mathe` <- as.factor( Datensatz$`Int. Mathe`)
Datensatz$`Int. Mathe` <- ordered( Datensatz$`Int. Mathe` , levels = c("1", "2", "3", "4", "5", "6", "7") )
Datensatz$`Int. Prog.` <- as.factor( Datensatz$`Int. Prog.`)
Datensatz$`Int. Prog.` <- ordered( Datensatz$`Int. Prog.` , levels = c("1", "2", "3", "4", "5", "6", "7") )
Datensatz$`Mathe-LK` <- as.factor( Datensatz$`Mathe-LK`)
# Kontrolle:
str(Datensatz)
kat <- function(x){
if(is.character(x)){stop("Die Variable ist nicht kategoriell")}
else Modalwert <- names(table(x)[table(x) == max(table(x))]) ##Auspraegung, die am haeufigsten vorkommt
Maximum <- max(x)
Minimum <- min(x)
Spannweite <- length(unique(x)) ##Anzahl der verschiedenen Auspraegungen der Variablen
uebersicht_kat <- list("Modalwert" = Modalwert, "Maximum" = Maximum, "Minimum" = Minimum, "Spannweite" = Spannweite) ##bringe Werte in eine Liste
return(uebersicht_kat) ##gibt die Liste aus
}
sapply( Datensatz[ ,5:6], kat)
# Data Science
sapply( ds[ ,5:6], kat)         # Beim Vergleich der Modalwerte ergibt sich:
# Statistik
sapply( st[ ,5:6], kat)
# Informatik
sapply( inf[ ,5:6], kat)
# Mathe
sapply( ma[ ,5:6], kat)         # Mit dem Modalwert von 5 bei Int.Mathe scheint im Vergleich zum Modalwert
table(Datensatz$`Mathe-LK`) # Die Mehrheit der Studierenden hat einen Mathe-LK belegt.
# Data Science            # Recht ausgeglichenes Verhaeltniss.
table(ds$`Mathe-LK`)
# Statistik               # Deutlich mehr Studierende haben den Mathe-LK besucht.
table(st$`Mathe-LK`)
# Informatik              # Etwas mehr Studierende haben den Mathe-LK besucht.(auch eher ausgeglichen)
table(inf$`Mathe-LK`)
# Mathe
table(ma$`Mathe-LK`)      # Nahezu alle Studierende haben den Mathe-LK besucht.
kat_zsh <- function(x,y){
# Zunaechst eine Bedingung, die die beiden Vektoren erfuellen sollen:
if( length(x) != length(y) ){ stop("Beide Objekte muessen dieselbe Laenge haben.")}
kor <- cor( as.numeric(x), as.numeric(y) )
kov <- cov( as.numeric(x), as.numeric(y) )
return( list( Kovarianz = kov, Korrelation = kor) )  # Ausgabe in einer Liste
}
kat_zsh(Datensatz$`Int. Prog.`, Datensatz$`Int. Mathe`)
kat_zsh(Datensatz$Alter, Datensatz$`Int. Mathe`)
kat_zsh(Datensatz$Alter, Datensatz$`Int. Prog.`)
Datensatz$`Int. Mathe` <- as.numeric(Datensatz$`Int. Mathe`)
Datensatz$`Int. Prog.` <- as.numeric(Datensatz$`Int. Prog.`)
Datensatz$`Mathe-LK` <- as.character(Datensatz$`Mathe-LK`)
dich_as_met <- function(x){
name <- unique(x)
result <- x == name[which.min(nchar(name))]
return(as.numeric(result))
}
met_dich <- function(x,y){
# x soll die metrische Variable sein
# y soll die dichotome Variable sein
if(!is.numeric(x)) stop("Der erste Vektor ist nicht metrisch")
if(length(levels(factor(y))) != 2) stop("Der zweite Vektor ist nicht dichotom")
y <- dich_as_met(y)
return(list("Korrelation" = cor(x,y), "Kovarianz" = cov(x,y),
"Lineares Modell" = lm(y~x)))
}
met_dich(Datensatz$`Int. Mathe`, Datensatz$`Mathe-LK`)
# Regressionsgerade:
y <- dich_as_met(Datensatz$`Mathe-LK`)
y
plot( y ~ Datensatz$`Int. Mathe` , ylab = "Besuch des Mathe-LK", xlab = "Interesse in Mathe",
main = "Zusmmenhang: Besuch Mathe-LK und Interesse in Mathe")
abline( 0.58992, 0.02187, col = "deepskyblue", lwd = 2)
met_dich(Datensatz$`Int. Prog.`, Datensatz$`Mathe-LK`)
# Regressionsgerade:
plot( y ~ Datensatz$`Int. Prog.`, xlab = "Interesse in Programmierung", ylab = "Besuch des Mathe-LK",
main = "Zusammenhang: Besuch Mathe-LK und Interesse in Programmierung")
abline( 0.637350 , 0.009584, col = "deepskyblue", lwd = 2)
# Wandle Variablen wieder in die korrekten Datentypen um
Datensatz$`Int. Mathe` <- as.factor( Datensatz$`Int. Mathe`)
Datensatz$`Int. Mathe` <- ordered( Datensatz$`Int. Mathe` , levels = c("1", "2", "3", "4", "5", "6", "7") )
Datensatz$`Int. Prog.` <- as.factor( Datensatz$`Int. Prog.`)
Datensatz$`Int. Prog.` <- ordered( Datensatz$`Int. Prog.` , levels = c("1", "2", "3", "4", "5", "6", "7") )
Datensatz$`Mathe-LK` <- as.factor( Datensatz$`Mathe-LK`)
# Funktion aus e):
qkat <- function(y){
if ( (is.numeric(y) == TRUE) || (is.ordered(y) == TRUE) )  {
x <- as.numeric(y)
x
n <- x[which( x <= quantile(x, 1/3))]
m <- x
m <- m [which( ! m <= quantile(x, 1/3))]
m <- m [which( ! m > quantile(x, 2/3))]
h <- x[which( x > quantile(x, 2/3))]
l <- list(n, m, h)
names(l) <- c("niedrig (<= 1/3-Quantil)", "mittel (1/3-Quantil < & <= 2/3-Quantil)", "hoch (2/3-Quantil <)")
return(l)
}
else{
stop("Nicht moeglich, da Variable nicht mindestens ordinalskaliert.")
}
}
qkat(Datensatz$`Int. Mathe`)
qkat(Datensatz$`Int. Prog.`)
# Funktion aus f):
visual <- function(x,i){
p <- length(i)
q <- sqrt(p)
if(round(q)^2 == p)
par(mfcol = c(q,q))
else
par(mfcol=c(q,q+1))
for (u in 1:p) {
barplot(table(x[i[u]]), xlab = colnames(Datensatz)[i[u]],
ylab = "abs. HÃ¤ufigkeit" ,main = "Visualisierung")
}
}
visual(Datensatz,3:6)
# Das Alter ist nahzu normalverteilt um 25 Jahre. Lediglich im Bereich 26 bis 27 liegen weniger
# Bei den Studiengaengen sind Data Science,Statistik und Informatik nahezu gleich oft vertreten.
library(readr)
Datensatz <- read_csv("Datensatz.csv")
Datensatz
sum_met <- function(x){
if( is.numeric(x) != TRUE){ stop("Die Variable muss metrisch skaliert sein.") } # Warnmeldung falls Variable
AM <- mean(x)                                                                  # nicht metrisch ist.
med <- median(x)    # Hier werden alle Statistiken berechnet.
var <- var(x)
sd <- sd(x)
quartile <- quantile(x, probs= c(0.25,0.75) )
extrm <- c( Minimum = min (x), Maximum = max (x))
return( list( "Arithmetische Mittel" = AM, "Median" = med, "Varianz" = var, "Standardabweichung" = sd,
"Quartile"= quartile, "Etremwerte" = extrm) )      # Alle benoetigten Groessen werden in einer Liste ausgegeben.
}
sum_met(Datensatz$Alter)    # Das durchschnittliche Alter liegt bei 24.34 Jahren bzw. (bezueglich des
sum_met(Datensatz$`Int. Mathe`)   # Int.Prog wirs insgesamte etwas hoher bewerte als Int.Mathe.
sum_met(Datensatz$`Int. Prog.`)   # vgl. Median von 4 bei Int.Mathe und Median von 5 bei Int.Prog.
# Moegliche Studienfaecher ausfindig machen:
unique( Datensatz$Studienfach)
table( Datensatz$Studienfach)/length( Datensatz$Studienfach)
# Erstellung von Teildatensaetzen um Unterschiede zwischen den Studiengaengen herausfinden zu koennen
ds <- Datensatz[ Datensatz$Studienfach == "Data Science", ]
st <- Datensatz[ Datensatz$Studienfach == "Statistik", ]
inf <- Datensatz[ Datensatz$Studienfach == "Informatik", ]
ma <- Datensatz[ Datensatz$Studienfach == "Mathe", ]
sapply( list( Data_Science = ds$`Int. Mathe`, Statistik = st$`Int. Mathe`,
Informatik = inf$`Int. Mathe`, Mathe = ma$`Int. Mathe`) , sum_met)[1:4,]
sapply( list( Data_Science = ds$`Int. Prog.`, Statistik = st$`Int. Prog.`,
Informatik = inf$`Int. Prog.`, Mathe = ma$`Int. Prog.`) , sum_met)[1:4,]
str(Datensatz)
Datensatz$`Int. Mathe` <- as.factor( Datensatz$`Int. Mathe`)
Datensatz$`Int. Mathe` <- ordered( Datensatz$`Int. Mathe` , levels = c("1", "2", "3", "4", "5", "6", "7") )
Datensatz$`Int. Prog.` <- as.factor( Datensatz$`Int. Prog.`)
Datensatz$`Int. Prog.` <- ordered( Datensatz$`Int. Prog.` , levels = c("1", "2", "3", "4", "5", "6", "7") )
Datensatz$`Mathe-LK` <- as.factor( Datensatz$`Mathe-LK`)
# Kontrolle:
str(Datensatz)
kat <- function(x){
if(is.character(x)){stop("Die Variable ist nicht kategoriell")}
else Modalwert <- names(table(x)[table(x) == max(table(x))]) ##Auspraegung, die am haeufigsten vorkommt
Maximum <- max(x)
Minimum <- min(x)
Spannweite <- length(unique(x)) ##Anzahl der verschiedenen Auspraegungen der Variablen
uebersicht_kat <- list("Modalwert" = Modalwert, "Maximum" = Maximum, "Minimum" = Minimum, "Spannweite" = Spannweite) ##bringe Werte in eine Liste
return(uebersicht_kat) ##gibt die Liste aus
}
sapply( Datensatz[ ,5:6], kat)
# Data Science
sapply( ds[ ,5:6], kat)         # Beim Vergleich der Modalwerte ergibt sich:
# Statistik
sapply( st[ ,5:6], kat)
# Informatik
sapply( inf[ ,5:6], kat)
# Mathe
sapply( ma[ ,5:6], kat)         # Mit dem Modalwert von 5 bei Int.Mathe scheint im Vergleich zum Modalwert
table(Datensatz$`Mathe-LK`) # Die Mehrheit der Studierenden hat einen Mathe-LK belegt.
# Data Science            # Recht ausgeglichenes Verhaeltniss.
table(ds$`Mathe-LK`)
# Statistik               # Deutlich mehr Studierende haben den Mathe-LK besucht.
table(st$`Mathe-LK`)
# Informatik              # Etwas mehr Studierende haben den Mathe-LK besucht.(auch eher ausgeglichen)
table(inf$`Mathe-LK`)
# Mathe
table(ma$`Mathe-LK`)      # Nahezu alle Studierende haben den Mathe-LK besucht.
kat_zsh <- function(x,y){
# Zunaechst eine Bedingung, die die beiden Vektoren erfuellen sollen:
if( length(x) != length(y) ){ stop("Beide Objekte muessen dieselbe Laenge haben.")}
kor <- cor( as.numeric(x), as.numeric(y) )
kov <- cov( as.numeric(x), as.numeric(y) )
return( list( Kovarianz = kov, Korrelation = kor) )  # Ausgabe in einer Liste
}
kat_zsh(Datensatz$`Int. Prog.`, Datensatz$`Int. Mathe`)
kat_zsh(Datensatz$Alter, Datensatz$`Int. Mathe`)
kat_zsh(Datensatz$Alter, Datensatz$`Int. Prog.`)
Datensatz$`Int. Mathe` <- as.numeric(Datensatz$`Int. Mathe`)
Datensatz$`Int. Prog.` <- as.numeric(Datensatz$`Int. Prog.`)
Datensatz$`Mathe-LK` <- as.character(Datensatz$`Mathe-LK`)
dich_as_met <- function(x){
name <- unique(x)
result <- x == name[which.min(nchar(name))]
return(as.numeric(result))
}
met_dich <- function(x,y){
# x soll die metrische Variable sein
# y soll die dichotome Variable sein
if(!is.numeric(x)) stop("Der erste Vektor ist nicht metrisch")
if(length(levels(factor(y))) != 2) stop("Der zweite Vektor ist nicht dichotom")
y <- dich_as_met(y)
return(list("Korrelation" = cor(x,y), "Kovarianz" = cov(x,y),
"Lineares Modell" = lm(y~x)))
}
met_dich(Datensatz$`Int. Mathe`, Datensatz$`Mathe-LK`)
# Regressionsgerade:
y <- dich_as_met(Datensatz$`Mathe-LK`)
y
plot( y ~ Datensatz$`Int. Mathe` , ylab = "Besuch des Mathe-LK", xlab = "Interesse in Mathe",
main = "Zusmmenhang: Besuch Mathe-LK und Interesse in Mathe")
abline( 0.58992, 0.02187, col = "deepskyblue", lwd = 2)
met_dich(Datensatz$`Int. Prog.`, Datensatz$`Mathe-LK`)
# Regressionsgerade:
plot( y ~ Datensatz$`Int. Prog.`, xlab = "Interesse in Programmierung", ylab = "Besuch des Mathe-LK",
main = "Zusammenhang: Besuch Mathe-LK und Interesse in Programmierung")
abline( 0.637350 , 0.009584, col = "deepskyblue", lwd = 2)
# Wandle Variablen wieder in die korrekten Datentypen um
Datensatz$`Int. Mathe` <- as.factor( Datensatz$`Int. Mathe`)
Datensatz$`Int. Mathe` <- ordered( Datensatz$`Int. Mathe` , levels = c("1", "2", "3", "4", "5", "6", "7") )
Datensatz$`Int. Prog.` <- as.factor( Datensatz$`Int. Prog.`)
Datensatz$`Int. Prog.` <- ordered( Datensatz$`Int. Prog.` , levels = c("1", "2", "3", "4", "5", "6", "7") )
Datensatz$`Mathe-LK` <- as.factor( Datensatz$`Mathe-LK`)
# Funktion aus e):
qkat <- function(y){
if ( (is.numeric(y) == TRUE) || (is.ordered(y) == TRUE) )  {
x <- as.numeric(y)
x
n <- x[which( x <= quantile(x, 1/3))]
m <- x
m <- m [which( ! m <= quantile(x, 1/3))]
m <- m [which( ! m > quantile(x, 2/3))]
h <- x[which( x > quantile(x, 2/3))]
l <- list(n, m, h)
names(l) <- c("niedrig (<= 1/3-Quantil)", "mittel (1/3-Quantil < & <= 2/3-Quantil)", "hoch (2/3-Quantil <)")
return(l)
}
else{
stop("Nicht moeglich, da Variable nicht mindestens ordinalskaliert.")
}
}
qkat(Datensatz$`Int. Mathe`)
qkat(Datensatz$`Int. Prog.`)
# Funktion aus f):
visual <- function(x,i){
p <- length(i)
q <- sqrt(p)
if(round(q)^2 == p)
par(mfcol = c(q,q))
else
par(mfcol=c(q,q+1))
for (u in 1:p) {
barplot(table(x[i[u]]), xlab = colnames(Datensatz)[i[u]],
ylab = "abs. HÃ¤ufigkeit" ,main = "Visualisierung")
}
}
visual(Datensatz,3:6)
# Das Alter ist nahzu normalverteilt um 25 Jahre. Lediglich im Bereich 26 bis 27 liegen weniger
# Bei den Studiengaengen sind Data Science,Statistik und Informatik nahezu gleich oft vertreten.
# Hier bestaetigen sich bei der Verteilung der Bewertungsstufen die Erkenntnisse aus e). Beim Mathe-
# Hier bestaetigen sich bei der Verteilung der Bewertungsstufen die Erkenntnisse aus e). Beim Mathe-
# Interesse sind die Beobachtungen deutlich gleichmaessiger verteilt als beim Programmierungs-
# Beim Programmierungs-Interesse ist eine Tendez zur Linksschiefe erkennbar.
####################################################################################################
####################################################################################################
# Zusammmenfassung:
