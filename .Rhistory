library(readr)
Datensatz <- read_csv("Datensatz.csv")
Datensatz
str(Datensatz)
Datensatz$`Int. Mathe` <- as.factor( Datensatz$`Int. Mathe`)
Datensatz$`Int. Mathe` <- ordered( Datensatz$`Int. Mathe` , levels = c("1", "2", "3", "4", "5", "6", "7") )
Datensatz$`Int. Prog.` <- as.factor( Datensatz$`Int. Prog.`)
Datensatz$`Int. Prog.` <- ordered( Datensatz$`Int. Prog.` , levels = c("1", "2", "3", "4", "5", "6", "7") )
Datensatz$`Mathe-LK` <- as.factor( Datensatz$`Mathe-LK`)
# Nun haben alle Variablen den korrekten Objekttyp:
str(Datensatz)
sum_met <- function(x){
if( is.numeric(x) != TRUE){ stop("Die Variable muss metrisch skaliert sein.") } # Warnmeldung falls Variable
AM <- mean(x)                                                                  # nicht metrisch ist.
med <- median(x)    # Hier werden alle Statistiken berechnet.
var <- var(x)
sd <- sd(x)
quartile <- quantile(x, probs= c(0.25,0.75) )
extrm <- c( Minimum = min (x), Maximum = max (x))
return( list( "Arithmetische Mittel" = AM, "Median" = med, "Varianz" = var, "Standardabweichung" = sd,
"Quartile"= quartile, "Etremwerte" = extrm) )      # Alle benoetigten Groessen werden in einer Liste ausgegeben.
}
sum_met(Datensatz$Alter)    # Das durchschnittliche Alter liegt bei 24.34 Jahren bzw. (bezueglich des
kat <- function(x){
if(is.character(x)){stop("Die Variable ist nicht kategoriell")}
else Modalwert <- names(table(x)[table(x) == max(table(x))]) ##Auspraegung, die am haeufigsten vorkommt
Maximum <- max(x)
Minimum <- min(x)
Spannweite <- length(unique(x)) ##Anzahl der verschiedenen Auspraegungen der Variablen
uebersicht_kat <- list("Modalwert" = Modalwert, "Maximum" = Maximum, "Minimum" = Minimum, "Spannweite" = Spannweite) ##bringe Werte in eine Liste
return(uebersicht_kat) ##gibt die Liste aus
}
sapply( Datensatz[ ,5:6], kat)
# Moegliche Studienfaecher ausfindig machen:
unique( Datensatz$Studienfach)
ds <- Datensatz[ Datensatz$Studienfach == "Data Science", ]
st <- Datensatz[ Datensatz$Studienfach == "Statistik", ]
inf <- Datensatz[ Datensatz$Studienfach == "Informatik", ]
ma <- Datensatz[ Datensatz$Studienfach == "Mathe", ]
# Data Science
sapply( ds[ ,5:6], kat)         # Beim Vergleich der Modalwerte ergibt sich:
# Statistik
sapply( st[ ,5:6], kat)
# Informatik
sapply( inf[ ,5:6], kat)
# Mathe
sapply( ma[ ,5:6], kat)         # Mit dem Modalwert von 5 bei Int.Mathe scheint im Vergleich zum Modalwert
table(Datensatz$`Mathe-LK`) # Die Mehrheit der Studierenden hat einen Mathe-LK belegt.
# Data Science            # Recht ausgeglichenes Verhaeltniss.
table(ds$`Mathe-LK`)
# Statistik               # Deutlich mehr Studierende haben den Mathe-LK besucht.
table(st$`Mathe-LK`)
# Informatik              # Etwas mehr Studierende haben den Mathe-LK besucht.(auch eher ausgeglichen)
table(inf$`Mathe-LK`)
# Mathe
table(ma$`Mathe-LK`)      # Nahezu alle Studierende haben den Mathe-LK besucht.
kat_zsh <- function(x,y){
# Zunaechst eine Bedingung, die die beiden Vektoren erfuellen sollen:
if( length(x) != length(y) ){ stop("Beide Objekte muessen dieselbe Laenge haben.")}
kor <- cor( as.numeric(x), as.numeric(y) )
kov <- cov( as.numeric(x), as.numeric(y) )
return( list( Kovarianz = kov, Korrelation = kor) )  # Ausgabe in einer Liste
}
kat_zsh(Datensatz$`Int. Prog.`, Datensatz$`Int. Mathe`)
kat_zsh(Datensatz$Alter, Datensatz$`Int. Mathe`)
kat_zsh(Datensatz$Alter, Datensatz$`Int. Prog.`)
Datensatz$`Int. Mathe` <- as.numeric(Datensatz$`Int. Mathe`)
Datensatz$`Int. Prog.` <- as.numeric(Datensatz$`Int. Prog.`)
Datensatz$`Mathe-LK` <- as.character(Datensatz$`Mathe-LK`)
dich_as_met <- function(x){
name <- unique(x)
result <- x == name[which.min(nchar(name))]
return(as.numeric(result))
}
met_dich <- function(x,y){
# x soll die metrische Variable sein
# y soll die dichotome Variable sein
if(!is.numeric(x)) stop("Der erste Vektor ist nicht metrisch")
if(length(levels(factor(y))) != 2) stop("Der zweite Vektor ist nicht dichotom")
y <- dich_as_met(y)
return(list("Korrelation" = cor(x,y), "Kovarianz" = cov(x,y),
"Lineares Modell" = lm(y~x)))
}
met_dich(Datensatz$`Int. Mathe`, Datensatz$`Mathe-LK`)
met_dich(Datensatz$`Int. Prog.`, Datensatz$`Mathe-LK`)
# Wandle Variablen wieder in die korrekten Datentypen um
Datensatz$`Int. Mathe` <- as.factor( Datensatz$`Int. Mathe`)
Datensatz$`Int. Mathe` <- ordered( Datensatz$`Int. Mathe` , levels = c("1", "2", "3", "4", "5", "6", "7") )
Datensatz$`Int. Prog.` <- as.factor( Datensatz$`Int. Prog.`)
Datensatz$`Int. Prog.` <- ordered( Datensatz$`Int. Prog.` , levels = c("1", "2", "3", "4", "5", "6", "7") )
Datensatz$`Mathe-LK` <- as.factor( Datensatz$`Mathe-LK`)
# Funktion aus e):
qkat <- function(y){
if ( (is.numeric(y) == TRUE) || (is.ordered(y) == TRUE) )  {
x <- as.numeric(y)
x
n <- x[which( x <= quantile(x, 1/3))]
m <- x
m <- m [which( ! m <= quantile(x, 1/3))]
m <- m [which( ! m > quantile(x, 2/3))]
h <- x[which( x > quantile(x, 2/3))]
l <- list(n, m, h)
names(l) <- c("niedrig (<= 1/3-Quantil)", "mittel (1/3-Quantil < & <= 2/3-Quantil)", "hoch (2/3-Quantil <)")
return(l)
}
else{
stop("Nicht moeglich, da Variable nicht mindestens ordinalskaliert.")
}
}
qkat(Datensatz$`Int. Mathe`)
# Funktion aus f):
visual <- function(x,i){
p <- length(i)
q <- sqrt(p)
if(round(q)^2 == p)
par(mfcol = c(q,q))
else
par(mfcol=c(q,q+1))
for (u in 1:p) {
barplot(table(x[i[u]]), xlab = colnames(Datensatz)[i[u]],
ylab = "abs. HÃ¤ufigkeit" ,main = "Visualisierung")
}
}
visual(Datensatz,3:6)
dich_as_met <- function(x){
name <- unique(x)
result <- x == name[which.min(nchar(name))]
return(as.numeric(result))
}
met_dich <- function(x,y){
# x soll die metrische Variable sein
# y soll die dichotome Variable sein
if(!is.numeric(x)) stop("Der erste Vektor ist nicht metrisch")
if(length(levels(factor(y))) != 2) stop("Der zweite Vektor ist nicht dichotom")
y <- dich_as_met(y)
return(list("Korrelation" = cor(x,y), "Kovarianz" = cov(x,y),
"Lineares Modell" = lm(y~x)))
}
met_dich(Datensatz$`Int. Mathe`, Datensatz$`Mathe-LK`)
library(readr)
Datensatz <- read_csv("Datensatz.csv")
Datensatz
met_dich(Datensatz$`Int. Mathe`, Datensatz$`Mathe-LK`)
lm( Datensatz$`Int. Mathe` ~ Datensatz$`Int. Prog.` )
plot( Datensatz$`Int. Mathe` ~ Datensatz$`Int. Prog.` )
dev.off()
plot( Datensatz$`Int. Mathe` ~ Datensatz$`Int. Prog.` )
abline( 0.58992, 0.02187)
?abline
lm(Datensatz$`Int. Mathe` ~ Datensatz$`Int. Prog.`)
lm <- lm(Datensatz$`Int. Mathe` ~ Datensatz$`Int. Prog.`)
plot(lm)
plot(Datensatz$`Int. Mathe` ~ Datensatz$`Int. Prog.`)
abline(lm)
plot( Datensatz$`Int. Mathe` ~ Datensatz$`Mathe-LK` )
plot( Datensatz$`Int. Mathe` ~ Datensatz$`Mathe-LK` )
lm <- lm(Datensatz$`Int. Mathe` ~ Datensatz$`Mathe-LK`)
plot(Datensatz$`Int. Mathe` ~ Datensatz$`Mathe-LK`)
abline(lm)
plot( Datensatz$`Int. Mathe` ~ as.numeric( Datensatz$`Mathe-LK` ) )
y <- dich_as_met(Datensatz$`Mathe-LK`)
plot( y ~ Datensatz$`Mathe-LK` )
y
plot( y ~ Datensatz$`Int. Mathe` )
abline( 0.58992, 0.02187)
lm <- lm(y ~ Datensatz$`Int. Mathe`)
lm <- lm(y ~ Datensatz$`Int. Mathe`)
lm
plot(y ~ Datensatz$`Int. Mathe`)
abline(lm)
plot( y ~ Datensatz$`Int. Prog.` )
y <- dich_as_met(Datensatz$`Mathe-LK`)
y
plot( y ~ Datensatz$`Int. Prog.` )
abline( 0.637350 , 0.009584)
lm( Datensatz$`Int. Mathe` ~ y)
c <- lm( Datensatz$`Int. Mathe` ~ y)
c <- lm( y <- dich_as_met(Datensatz$`Mathe-LK`))
c <- lm( Datensatz$`Int. Mathe` ~ y)
plot(Datensatz$`Int. Mathe` ~ y)
abline(c)
lm( Datensatz$Alter ~ Datensatz$`Int. Mathe`)
lm( Datensatz$Alter ~ Datensatz$`Int. Mathe`)
plot(Datensatz$Alter ~ Datensatz$`Int. Mathe`)
k <- lm( Datensatz$Alter ~ Datensatz$`Int. Mathe`)
plot(Datensatz$Alter ~ Datensatz$`Int. Mathe`)
abline(k)
plot( y ~ Datensatz$`Int. Mathe` )
abline( 0.58992, 0.02187)
# Funktion aus e):
qkat <- function(y){
if ( (is.numeric(y) == TRUE) || (is.ordered(y) == TRUE) )  {
x <- as.numeric(y)
x
n <- x[which( x <= quantile(x, 1/3))]
m <- x
m <- m [which( ! m <= quantile(x, 1/3))]
m <- m [which( ! m > quantile(x, 2/3))]
h <- x[which( x > quantile(x, 2/3))]
l <- list(n, m, h)
names(l) <- c("niedrig (<= 1/3-Quantil)", "mittel (1/3-Quantil < & <= 2/3-Quantil)", "hoch (2/3-Quantil <)")
return(l)
}
else{
stop("Nicht moeglich, da Variable nicht mindestens ordinalskaliert.")
}
}
qkat(Datensatz$`Int. Mathe`)
# Funktion aus f):
visual <- function(x,i){
p <- length(i)
q <- sqrt(p)
if(round(q)^2 == p)
par(mfcol = c(q,q))
else
par(mfcol=c(q,q+1))
for (u in 1:p) {
barplot(table(x[i[u]]), xlab = colnames(Datensatz)[i[u]],
ylab = "abs. HÃ¤ufigkeit" ,main = "Visualisierung")
}
}
visual(Datensatz,3:6)
qkat(Datensatz$`Int. Prog.`)
View(Datensatz)
ordered( Datensatz$`Int. Prog.`)
ordered( as.numeric(Datensatz$`Int. Prog.`))
# Funktion aus f):
visual <- function(x,i){
p <- length(i)
q <- sqrt(p)
if(round(q)^2 == p)
par(mfcol = c(q,q))
else
par(mfcol=c(q,q+1))
for (u in 1:p) {
barplot(table(x[i[u]]), xlab = colnames(Datensatz)[i[u]],
ylab = "abs. HÃ¤ufigkeit" ,main = "Visualisierung")
}
}
visual(Datensatz,3:6)
